From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Proxmox Script Guardian <noreply@example.com>
Date: Sat, 25 Oct 2025 00:00:00 +0000
Subject: [PATCH] analyzer: richer ruleset, structured findings, updated tests

---
 src/analyzer/rules.py       |  88 ++++++++++++++++++++++++++++++---------------
 scripts/run_scan.py        |  50 ++++++++++++++++++++++---------
 tests/test_rules.py        |  36 ++++++++++++++++++----
 3 files changed, 126 insertions(+), 48 deletions(-)
---
diff --git a/src/analyzer/rules.py b/src/analyzer/rules.py
index 0000000..0000000 100644
--- a/src/analyzer/rules.py
+++ b/src/analyzer/rules.py
@@ -1,63 +1,103 @@
-"""
-Minimal static analyzer rules for bash scripts.
-This is intentionally simple: file-based regex checks that produce findings.
-Add tests in tests/test_rules.py to expand coverage.
-"""
-
-import re
-from dataclasses import dataclass
-from typing import List
-
-@dataclass
-class Finding:
-    line_no: int
-    pattern: str
-    message: str
-
-RULES = [
-    (re.compile(r"source\s+<\(\s*curl"), "Remote source via curl: executes remote code"),
-    (re.compile(r"curl\s+.*\|\s*(sh|bash)"), "Piped curl to shell"),
-    (re.compile(r"wget\s+.*-O\s*-\s*\|\s*(sh|bash)"), "Piped wget to shell"),
-    (re.compile(r"rm\s+-rf\s+/\b"), "Dangerous rm -rf / pattern"),
-    (re.compile(r"dd\s+if="), "Possible disk write with dd"),
-    (re.compile(r"mkfs\."), "Filesystem creation"),
-    (re.compile(r"chmod\s+4755"), "SUID set on file"),
-    (re.compile(r"chmod\s+777"), "World-writable permission"),
-    (re.compile(r"ssh-copy-id|authorized_keys"), "SSH key installation or injection"),
-    (re.compile(r"base64\s+-d|openssl\s+enc\s+-d"), "Decoding and executing blobs")
-]
-
-def analyze_script(text: str) -> List[Finding]:
-    findings: List[Finding] = []
-    for i, line in enumerate(text.splitlines(), start=1):
-        for pattern, message in RULES:
-            if pattern.search(line):
-                findings.append(Finding(line_no=i, pattern=pattern.pattern, message=message))
-    return findings
+"""Static analyzer rules for Proxmox Script Guardian.
+
+This module provides a small, test-driven ruleset for detecting risky shell
+patterns in helper scripts. Rules are intended to be conservative heuristics
+which produce findings that should be reviewed manually.
+"""
+
+import re
+from dataclasses import dataclass
+from typing import List, Tuple
+
+@dataclass
+class Finding:
+    line_no: int
+    rule_id: str
+    severity: str
+    message: str
+
+# RULES: tuple(rule_id, severity, compiled_regex, message)
+# severity: "info", "warning", "danger"
+RULES: List[Tuple[str, str, re.Pattern, str]] = [
+    ("R001", "danger", re.compile(r"source\s+<\(\s*curl"), "Remote source via curl: executes remote code"),
+    ("R002", "danger", re.compile(r"curl\s+.*\|\s*(sh|bash)"), "Piped curl to shell"),
+    ("R003", "danger", re.compile(r"wget\s+.*-O\s*-\s*\|\s*(sh|bash)"), "Piped wget to shell"),
+    ("R004", "danger", re.compile(r"rm\s+-rf\s+/\b"), "Dangerous rm -rf / pattern"),
+    ("R005", "danger", re.compile(r"\bdd\s+if="), "Potential raw disk write with dd"),
+    ("R006", "warning", re.compile(r"mkfs\."), "Filesystem creation (mkfs)"),
+    ("R007", "warning", re.compile(r"chmod\s+4755"), "SUID bit being set (chmod 4755)"),
+    ("R008", "warning", re.compile(r"chmod\s+777"), "World-writable permissions (chmod 777)"),
+    ("R009", "warning", re.compile(r"ssh-copy-id|authorized_keys"), "SSH key installation or authorized_keys modification"),
+    ("R010", "warning", re.compile(r"base64\s+-d|openssl\s+enc\s+-d"), "Decoding / executing encoded blobs"),
+    ("R011", "warning", re.compile(r"apt-key\s+add"), "Adding apt key to system (apt-key add)"),
+    ("R012", "warning", re.compile(r"--allow-unauthenticated"), "apt-get install with --allow-unauthenticated"),
+    ("R013", "warning", re.compile(r"useradd|adduser|passwd\s"), "User creation or password modification"),
+    ("R014", "warning", re.compile(r"systemctl\s+(enable|start|restart|daemon-reload)"), "systemd unit modification / control"),
+    ("R015", "warning", re.compile(r"releases/download|\.deb\b|\.rpm\b|\.tar\.gz\b"), "Downloading binary artifacts (inspect for checksums)"),
+    ("R016", "info", re.compile(r"curl\s+https?://(raw\.githubusercontent|raw\.github\.com)"), "Fetching raw content from GitHub raw; still check contents"),
+]
+
+def analyze_script(text: str) -> List[Finding]:
+    """Analyze provided script text and return list of Findings.
+
+    This is intentionally line-based and conservative; false positives are
+    possible and findings should be manually inspected.
+    """
+    findings: List[Finding] = []
+    for i, line in enumerate(text.splitlines(), start=1):
+        for rule_id, severity, pattern, message in RULES:
+            if pattern.search(line):
+                findings.append(Finding(line_no=i, rule_id=rule_id, severity=severity, message=message))
+    return findings
diff --git a/scripts/run_scan.py b/scripts/run_scan.py
index 0000000..0000000 100644
--- a/scripts/run_scan.py
+++ b/scripts/run_scan.py
@@ -1,30 +1,66 @@
-#!/usr/bin/env python3
-"""
-Static scan runner for CI and local runs.
-This modifies sys.path so imports work regardless of PYTHONPATH.
-"""
-import sys
-import os
-import glob
-import json
-
-# Ensure repo root is on sys.path so `from src.analyzer...` works.
-REPO_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
-if REPO_ROOT not in sys.path:
-    sys.path.insert(0, REPO_ROOT)
-
-# Now import the analyzer via the src package
-from src.analyzer.rules import analyze_script
-
-def main():
-    print("Scanning repository scripts...")
-    issues = {}
-    for path in glob.glob("**/*.sh", recursive=True):
-        try:
-            with open(path, "r", encoding="utf-8") as fh:
-                content = fh.read()
-        except Exception as e:
-            print(f"Could not read {path}: {e}")
-            continue
-        findings = analyze_script(content)
-        if findings:
-            issues[path] = [f.__dict__ for f in findings]
-
-    print(json.dumps(issues, indent=2))
-    if issues:
-        print("Warnings found")
-
-if __name__ == "__main__":
-    main()
+#!/usr/bin/env python3
+"""
+Static scan runner for CI and local runs.
+This modifies sys.path so imports work regardless of PYTHONPATH.
+Outputs a JSON object with findings per file.
+"""
+import sys
+import os
+import glob
+import json
+from typing import Dict, Any
+
+# Ensure repo root is on sys.path so `from src.analyzer...` works.
+REPO_ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
+if REPO_ROOT not in sys.path:
+    sys.path.insert(0, REPO_ROOT)
+
+# Import the analyzer from the package
+try:
+    from src.analyzer.rules import analyze_script
+except Exception:
+    # Fallback: try direct import if PYTHONPATH points at src
+    from analyzer.rules import analyze_script  # type: ignore
+
+def main() -> None:
+    print("Scanning repository scripts...")
+    issues: Dict[str, Any] = {}
+    for path in glob.glob("**/*.sh", recursive=True):
+        try:
+            with open(path, "r", encoding="utf-8") as fh:
+                content = fh.read()
+        except Exception as e:
+            print(f"Could not read {path}: {e}")
+            continue
+        findings = analyze_script(content)
+        if findings:
+            issues[path] = [
+                {
+                    "line_no": f.line_no,
+                    "rule_id": f.rule_id,
+                    "severity": f.severity,
+                    "message": f.message,
+                }
+                for f in findings
+            ]
+
+    # Print JSON summary
+    print(json.dumps(issues, indent=2))
+    if issues:
+        print("Warnings found")
+
+if __name__ == "__main__":
+    main()
diff --git a/tests/test_rules.py b/tests/test_rules.py
index 0000000..0000000 100644
--- a/tests/test_rules.py
+++ b/tests/test_rules.py
@@ -1,8 +1,35 @@
-from src.analyzer.rules import analyze_script
-
-def test_detects_remote_source():
-    txt = "source <(curl -fsSL https://example.com/whatever)\n echo hi"
-    findings = analyze_script(txt)
-    assert any("Remote source" in f.message for f in findings)
+from src.analyzer.rules import analyze_script
+
+
+def _find_rule(findings, rule_id):
+    return [f for f in findings if f.rule_id == rule_id]
+
+
+def test_detects_remote_source():
+    txt = "source <(curl -fsSL https://example.com/whatever)\n echo hi"
+    findings = analyze_script(txt)
+    assert len(findings) >= 1
+    # should include R001 (remote source) and be a danger
+    r = _find_rule(findings, "R001")
+    assert r and r[0].severity == "danger"
+
+
+def test_detects_piped_curl_and_rm():
+    txt = "curl -s http://example.com/install.sh | bash\nsudo rm -rf /tmp/test\n"
+    findings = analyze_script(txt)
+    assert _find_rule(findings, "R002")  # piped curl
+    assert _find_rule(findings, "R004")  # dangerous rm -rf
+    # piped curl should be danger
+    assert any(f.rule_id == "R002" and f.severity == "danger" for f in findings)
+    # rm -rf should be danger
+    assert any(f.rule_id == "R004" and f.severity == "danger" for f in findings)
+
-- 
2.40.1
